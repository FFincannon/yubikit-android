/*
 * Copyright (C) 2019 Yubico.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.yubico.yubikit.fido;

import android.os.Parcel;
import android.os.Parcelable;

import com.google.android.gms.fido.fido2.api.common.AuthenticatorAssertionResponse;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

/**
 * {@code GetAssertionResponse} represents response from authenticator that needs to be sent to server for authentication
 */
public class GetAssertionResponse implements Parcelable, AuthenticatorResponse {

    /**
     * A probabilistically-unique byte sequence identifying a public key credential source and its authentication assertions.
     * Credential IDs are generated by authenticators in two forms:
     * At least 16 bytes that include at least 100 bits of entropy, or
     * The public key credential source, without its Credential ID, encrypted so only its managing authenticator can decrypt it.
     * This form allows the authenticator to be nearly stateless, by having the Relying Party store any necessary state.
     */
    @NonNull private byte[] keyHandle;

    /**
     * The client data represents the contextual bindings of both the WebAuthn Relying Party and the client.
     * It is a key-value mapping whose keys are strings.
     * Values can be any type that has a valid encoding in JSON. Its structure is defined by the following Web IDL.
     */
    @NonNull private byte[] clientDataJson;

    /**
     * The authenticator data structure encodes contextual bindings made by the authenticator.
     * These bindings are controlled by the authenticator itself, and derive their trust from the WebAuthn Relying Party's assessment
     * of the security properties of the authenticator.
     */
    @NonNull private byte[] authenticatorData;

    /**
     * Assertion signature of the concatenation authenticatorData || hash using the privateKey of selectedCredential
     */
    @NonNull private byte[] signature;

    /**
     * The user handle is specified by a Relying Party, as the value of user.id, and used to map a specific public key credential
     * to a specific user account with the Relying Party.
     * Authenticators in turn map RP IDs and user handle pairs to public key credential sources.
     */
    @Nullable private byte[] userHandle;

    GetAssertionResponse(AuthenticatorAssertionResponse response) {
        keyHandle = response.getKeyHandle();
        clientDataJson = response.getClientDataJSON();
        authenticatorData = response.getAuthenticatorData();
        signature = response.getSignature();
        userHandle = response.getUserHandle();
    }

    protected GetAssertionResponse(Parcel in) {
        keyHandle = in.createByteArray();
        clientDataJson = in.createByteArray();
        authenticatorData = in.createByteArray();
        signature = in.createByteArray();
        userHandle = in.createByteArray();
    }

    public static final Creator<GetAssertionResponse> CREATOR = new Creator<GetAssertionResponse>() {
        @Override
        public GetAssertionResponse createFromParcel(Parcel in) {
            return new GetAssertionResponse(in);
        }

        @Override
        public GetAssertionResponse[] newArray(int size) {
            return new GetAssertionResponse[size];
        }
    };

    /**
     * @return A probabilistically-unique byte sequence identifying a public key credential source and its authentication assertions.
     * Credential IDs are generated by authenticators in two forms:
     * At least 16 bytes that include at least 100 bits of entropy, or
     * The public key credential source, without its Credential ID, encrypted so only its managing authenticator can decrypt it.
     * This form allows the authenticator to be nearly stateless, by having the Relying Party store any necessary state.
     */
    public byte[] getKeyHandle() {
        return keyHandle;
    }

    /**
     * @return The client data represents the contextual bindings of both the WebAuthn Relying Party and the client.
     * It is a key-value mapping whose keys are strings.
     * Values can be any type that has a valid encoding in JSON. Its structure is defined by the following Web IDL.
     */
    public byte[] getClientDataJSON() {
        return clientDataJson;
    }

    /**
     * @return The authenticator data structure encodes contextual bindings made by the authenticator.
     * These bindings are controlled by the authenticator itself, and derive their trust from the WebAuthn Relying Party's assessment
     * of the security properties of the authenticator.
     */
    public byte[] getAuthenticatorData() {
        return authenticatorData;
    }

    /**
     * @return Assertion signature of the concatenation authenticatorData || hash using the privateKey of selectedCredential
     */
    public byte[] getSignature() {
        return signature;
    }

    /**
     * @return The user handle is specified by a Relying Party, as the value of user.id, and used to map a specific public key credential
     * to a specific user account with the Relying Party.
     * Authenticators in turn map RP IDs and user handle pairs to public key credential sources.
     */
    @Nullable
    public byte[] getUserHandle() {
        return userHandle;
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeByteArray(keyHandle);
        dest.writeByteArray(clientDataJson);
        dest.writeByteArray(authenticatorData);
        dest.writeByteArray(signature);
        dest.writeByteArray(userHandle);
    }
}
